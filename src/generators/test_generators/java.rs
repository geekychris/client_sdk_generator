// Copyright (c) 2024 Chris Collins <chris@hitorro.com>
// Licensed under the MIT License

use anyhow::{Context, Result};
use std::path::PathBuf;

use crate::core::config::TargetLanguage;
use crate::core::test_generation::*;
use crate::core::types::{ApiSpec, Operation, TypeDefinition, BaseType, HttpMethod};
use crate::generators::java::JavaGenerator;

pub struct JavaTestGenerator {
    java_generator: JavaGenerator,
}

impl JavaTestGenerator {
    pub fn new() -> Self {
        Self {
            java_generator: JavaGenerator::new(),
        }
    }

    fn generate_junit5_client_test(&self, api_spec: &ApiSpec) -> Result<String> {
        let package_name = "com.example.client";
        let class_name = format!("{}ApiClientTest", to_pascal_case(&api_spec.name));
        
        let mut content = format!(
            r#"package {};

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockitoExtension;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.net.http.HttpClient;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.concurrent.CompletableFuture;

/**
 * Unit tests for {}ApiClient
 * Generated by SDK Generator
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("{} API Client Tests")
public class {} {{
    
    @Mock
    private HttpClient mockHttpClient;
    
    @Mock
    private HttpResponse<String> mockResponse;
    
    private {}ApiClient client;
    private ClientConfig config;
    
    @BeforeEach
    void setUp() {{
        config = ClientConfig.builder()
            .baseUrl("https://api.example.com")
            .connectTimeoutSeconds(30)
            .requestTimeoutSeconds(60)
            .build();
        
        // Use reflection or constructor injection to set mock HttpClient
        client = new {}ApiClient(config);
        // TODO: Inject mockHttpClient using reflection or test constructor
    }}
    
"#,
            package_name,
            to_pascal_case(&api_spec.name),
            api_spec.name,
            class_name,
            to_pascal_case(&api_spec.name),
            to_pascal_case(&api_spec.name)
        );

        // Generate test methods for each operation
        for operation in &api_spec.operations {
            content.push_str(&self.generate_operation_test_methods(operation)?);
        }

        // Generate configuration tests
        content.push_str(&self.generate_config_tests()?);

        // Generate error handling tests
        content.push_str(&self.generate_error_handling_tests()?);

        content.push_str("}\n");

        Ok(content)
    }

    fn generate_operation_test_methods(&self, operation: &Operation) -> Result<String> {
        let method_name = to_camel_case(&operation.name);
        let test_cases = generate_test_cases_for_operation(operation);
        
        let mut content = String::new();
        
        for test_case in test_cases {
            for scenario in &test_case.test_scenarios {
                content.push_str(&format!(
                    r#"    @Test
    @DisplayName("{}")
    void {}() {{
        // Given
{}
        
        // When
{}
        
        // Then
{}
    }}
    
"#,
                    scenario.description,
                    to_camel_case(&scenario.name),
                    scenario.setup.join("\n        "),
                    scenario.execution.join("\n        "),
                    scenario.assertions.join("\n        ")
                ));
            }
        }

        // Generate specific success test
        content.push_str(&format!(
            r#"    @Test
    @DisplayName("Should successfully call {} operation")
    void test{}Success() throws Exception {{
        // Given
        when(mockHttpClient.send(any(), any())).thenReturn(mockResponse);
        when(mockResponse.statusCode()).thenReturn(200);
        when(mockResponse.body()).thenReturn("{{\"success\": true}}");
        
        // When
        var result = client.{}({});
        
        // Then
        assertNotNull(result);
        verify(mockHttpClient).send(any(), any());
    }}
    
"#,
            operation.name,
            to_pascal_case(&method_name),
            method_name,
            self.generate_method_parameters(operation)?
        ));

        // Generate parameter validation tests
        for param in &operation.parameters {
            if param.required {
                content.push_str(&format!(
                    r#"    @Test
    @DisplayName("Should throw exception when {} is null")
    void test{}With{}Null() {{
        // Given/When/Then
        assertThrows(IllegalArgumentException.class, () -> {{
            client.{}({});
        }});
    }}
    
"#,
                    param.name,
                    to_pascal_case(&method_name),
                    to_pascal_case(&param.name),
                    method_name,
                    self.generate_method_parameters_with_null(operation, &param.name)?
                ));
            }
        }

        Ok(content)
    }

    fn generate_method_parameters(&self, operation: &Operation) -> Result<String> {
        if operation.parameters.is_empty() {
            return Ok(String::new());
        }

        let params: Vec<String> = operation.parameters
            .iter()
            .map(|p| {
                match &p.data_type.base_type {
                    BaseType::String => format!("\"test_{}\"", p.name),
                    BaseType::Integer => "123".to_string(),
                    BaseType::Long => "123L".to_string(),
                    BaseType::Boolean => "true".to_string(),
                    _ => format!("/* TODO: {} */", p.name),
                }
            })
            .collect();

        Ok(params.join(", "))
    }

    fn generate_method_parameters_with_null(&self, operation: &Operation, null_param: &str) -> Result<String> {
        if operation.parameters.is_empty() {
            return Ok(String::new());
        }

        let params: Vec<String> = operation.parameters
            .iter()
            .map(|p| {
                if p.name == null_param {
                    "null".to_string()
                } else {
                    match &p.data_type.base_type {
                        BaseType::String => format!("\"test_{}\"", p.name),
                        BaseType::Integer => "123".to_string(),
                        BaseType::Long => "123L".to_string(),
                        BaseType::Boolean => "true".to_string(),
                        _ => format!("/* TODO: {} */", p.name),
                    }
                }
            })
            .collect();

        Ok(params.join(", "))
    }

    fn generate_config_tests(&self) -> Result<String> {
        Ok(r#"    @Test
    @DisplayName("Should create client with valid config")
    void testClientCreationWithValidConfig() {
        // Given
        ClientConfig validConfig = ClientConfig.builder()
            .baseUrl("https://api.example.com")
            .connectTimeoutSeconds(30)
            .requestTimeoutSeconds(60)
            .build();
        
        // When
        var client = new PetStoreApiClient(validConfig);
        
        // Then
        assertNotNull(client);
    }
    
    @Test
    @DisplayName("Should throw exception with invalid config")
    void testClientCreationWithInvalidConfig() {
        // Given/When/Then
        assertThrows(IllegalArgumentException.class, () -> {
            new PetStoreApiClient(null);
        });
    }
    
"#.to_string())
    }

    fn generate_error_handling_tests(&self) -> Result<String> {
        Ok(r#"    @Test
    @DisplayName("Should handle HTTP 404 error")
    void testHandle404Error() throws Exception {
        // Given
        when(mockHttpClient.send(any(), any())).thenReturn(mockResponse);
        when(mockResponse.statusCode()).thenReturn(404);
        when(mockResponse.body()).thenReturn("{\"error\": \"Not Found\"}");
        
        // When/Then
        assertThrows(PetStoreApiException.class, () -> {
            // Call any operation - they should all handle 404 the same way
        });
    }
    
    @Test
    @DisplayName("Should handle network timeout")
    void testHandleNetworkTimeout() throws Exception {
        // Given
        when(mockHttpClient.send(any(), any())).thenThrow(new java.net.SocketTimeoutException("Timeout"));
        
        // When/Then
        assertThrows(PetStoreApiException.class, () -> {
            // Call any operation - they should all handle timeouts the same way
        });
    }
    
"#.to_string())
    }

    fn generate_model_test(&self, type_def: &TypeDefinition) -> Result<String> {
        let class_name = format!("{}Test", type_def.name);
        let package_name = "com.example.client.models";
        
        let mut content = format!(
            r#"package {};

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;

import static org.junit.jupiter.api.Assertions.*;

import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Unit tests for {} model
 * Generated by SDK Generator
 */
@DisplayName("{} Model Tests")
public class {} {{
    
    private ObjectMapper objectMapper;
    private {} model;
    
    @BeforeEach
    void setUp() {{
        objectMapper = new ObjectMapper();
        model = new {}();
    }}
    
"#,
            package_name,
            type_def.name,
            type_def.name,
            class_name,
            type_def.name,
            type_def.name
        );

        // Generate tests for each property
        for property in &type_def.properties {
            content.push_str(&self.generate_property_tests(type_def, property)?);
        }

        // Generate serialization tests
        content.push_str(&self.generate_serialization_tests(type_def)?);

        // Generate equals/hashCode tests
        content.push_str(&self.generate_equality_tests(type_def)?);

        content.push_str("}\n");

        Ok(content)
    }

    fn generate_property_tests(&self, type_def: &TypeDefinition, property: &crate::core::types::Property) -> Result<String> {
        let property_name = &property.name;
        let setter_name = format!("set{}", to_pascal_case(property_name));
        let getter_name = format!("get{}", to_pascal_case(property_name));
        let java_type = JavaGenerator::map_type_to_java(&property.data_type.base_type);
        
        let test_value = match &property.data_type.base_type {
            BaseType::String => "\"test_value\"".to_string(),
            BaseType::Integer => "123".to_string(),
            BaseType::Long => "123L".to_string(),
            BaseType::Boolean => "true".to_string(),
            BaseType::Double => "123.45".to_string(),
            BaseType::Float => "123.45f".to_string(),
            _ => "/* TODO: generate test value */".to_string(),
        };

        Ok(format!(
            r#"    @Test
    @DisplayName("Should set and get {}")
    void test{}GetterSetter() {{
        // Given
        {} expectedValue = {};
        
        // When
        model.{}(expectedValue);
        {} actualValue = model.{}();
        
        // Then
        assertEquals(expectedValue, actualValue);
    }}
    
    @Test
    @DisplayName("Should support fluent {} setting")
    void test{}FluentSetter() {{
        // Given
        {} value = {};
        
        // When
        {} result = model.with{}(value);
        
        // Then
        assertSame(model, result);
        assertEquals(value, model.{}());
    }}
    
"#,
            property_name,
            to_pascal_case(property_name),
            java_type,
            test_value,
            setter_name,
            java_type,
            getter_name,
            property_name,
            to_pascal_case(property_name),
            java_type,
            test_value,
            type_def.name,
            to_pascal_case(property_name),
            getter_name
        ))
    }

    fn generate_serialization_tests(&self, type_def: &TypeDefinition) -> Result<String> {
        Ok(format!(
            r#"    @Test
    @DisplayName("Should serialize to JSON")
    void testSerialization() throws Exception {{
        // Given
        {} model = new {}();
        // TODO: Set test data
        
        // When
        String json = objectMapper.writeValueAsString(model);
        
        // Then
        assertNotNull(json);
        assertFalse(json.isEmpty());
    }}
    
    @Test
    @DisplayName("Should deserialize from JSON")
    void testDeserialization() throws Exception {{
        // Given
        String json = "{{}}"; // TODO: Add valid JSON
        
        // When
        {} result = objectMapper.readValue(json, {}.class);
        
        // Then
        assertNotNull(result);
    }}
    
    @Test
    @DisplayName("Should handle round-trip serialization")
    void testRoundTripSerialization() throws Exception {{
        // Given
        {} original = new {}();
        // TODO: Set test data
        
        // When
        String json = objectMapper.writeValueAsString(original);
        {} deserialized = objectMapper.readValue(json, {}.class);
        
        // Then
        assertEquals(original, deserialized);
    }}
    
"#,
            type_def.name,
            type_def.name,
            type_def.name,
            type_def.name,
            type_def.name,
            type_def.name,
            type_def.name,
            type_def.name
        ))
    }

    fn generate_equality_tests(&self, type_def: &TypeDefinition) -> Result<String> {
        Ok(format!(
            r#"    @Test
    @DisplayName("Should implement equals correctly")
    void testEquals() {{
        // Given
        {} model1 = new {}();
        {} model2 = new {}();
        {} model3 = new {}();
        
        // TODO: Set same data for model1 and model2
        // TODO: Set different data for model3
        
        // When/Then
        assertEquals(model1, model2);
        assertNotEquals(model1, model3);
        assertEquals(model1, model1);
        assertNotEquals(model1, null);
        assertNotEquals(model1, "different type");
    }}
    
    @Test
    @DisplayName("Should implement hashCode correctly")
    void testHashCode() {{
        // Given
        {} model1 = new {}();
        {} model2 = new {}();
        
        // TODO: Set same data for both models
        
        // When/Then
        assertEquals(model1.hashCode(), model2.hashCode());
    }}
    
    @Test
    @DisplayName("Should implement toString correctly")
    void testToString() {{
        // Given
        {} model = new {}();
        
        // When
        String result = model.toString();
        
        // Then
        assertNotNull(result);
        assertTrue(result.contains("{}"));
    }}
    
"#,
            type_def.name, type_def.name,
            type_def.name, type_def.name,
            type_def.name, type_def.name,
            type_def.name, type_def.name,
            type_def.name, type_def.name,
            type_def.name, type_def.name,
            type_def.name
        ))
    }

    fn generate_integration_test(&self, api_spec: &ApiSpec) -> Result<String> {
        let class_name = format!("{}IntegrationTest", to_pascal_case(&api_spec.name));
        
        Ok(format!(
            r#"package com.example.client;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.condition.EnabledIfSystemProperty;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests for {}ApiClient
 * These tests require a running API server
 * Generated by SDK Generator
 */
@DisplayName("{} API Integration Tests")
@EnabledIfSystemProperty(named = "integration.tests.enabled", matches = "true")
public class {} {{
    
    private {}ApiClient client;
    
    @BeforeEach
    void setUp() {{
        ClientConfig config = ClientConfig.builder()
            .baseUrl(System.getProperty("api.base.url", "http://localhost:8080"))
            .connectTimeoutSeconds(30)
            .requestTimeoutSeconds(60)
            .build();
        
        client = new {}ApiClient(config);
    }}
    
    @Test
    @DisplayName("Should connect to API server")
    void testApiConnection() {{
        // This test verifies basic connectivity
        assertNotNull(client);
        // TODO: Add actual API call to verify connection
    }}
    
    // TODO: Add integration tests for each operation
    
}}
"#,
            to_pascal_case(&api_spec.name),
            api_spec.name,
            class_name,
            to_pascal_case(&api_spec.name),
            to_pascal_case(&api_spec.name)
        ))
    }

    fn generate_test_config_files(&self) -> Result<Vec<ConfigFile>> {
        let mut config_files = vec![];

        // JUnit 5 configuration
        config_files.push(ConfigFile {
            name: "junit-platform.properties".to_string(),
            path: PathBuf::from("src/test/resources/junit-platform.properties"),
            content: r#"# JUnit 5 Configuration
# Generated by SDK Generator

junit.jupiter.testinstance.lifecycle.default=per_class
junit.jupiter.execution.parallel.enabled=true
junit.jupiter.execution.parallel.mode.default=same_thread
"#.to_string(),
        });

        // Mockito configuration
        config_files.push(ConfigFile {
            name: "mockito-extensions".to_string(),
            path: PathBuf::from("src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker"),
            content: "mock-maker-inline\n".to_string(),
        });

        // Test logging configuration
        config_files.push(ConfigFile {
            name: "logback-test.xml".to_string(),
            path: PathBuf::from("src/test/resources/logback-test.xml"),
            content: r#"<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
    
    <!-- Set test-specific log levels -->
    <logger name="com.example.client" level="DEBUG"/>
</configuration>
"#.to_string(),
        });

        Ok(config_files)
    }
}

impl TestGenerator for JavaTestGenerator {
    fn generate_test_suite(&self, api_spec: &ApiSpec, config: &TestGenerationConfig, output_path: &PathBuf) -> Result<TestSuite> {
        let mut test_files = vec![];
        let mut mock_data_files = vec![];

        // Generate client tests
        if config.generate_unit_tests {
            test_files.extend(self.generate_client_tests(api_spec, config)?);
            test_files.extend(self.generate_model_tests(&api_spec.types, config)?);
        }

        // Generate integration tests
        if config.generate_integration_tests {
            test_files.extend(self.generate_integration_tests(api_spec, config)?);
        }

        // Generate mock data
        if config.generate_mock_data {
            mock_data_files.extend(self.generate_mock_data(api_spec, config)?);
        }

        let config_files = self.generate_test_configs(config)?;

        Ok(TestSuite {
            name: format!("{}_test_suite", api_spec.name),
            files: test_files,
            mock_data_files,
            config_files,
        })
    }

    fn generate_client_tests(&self, api_spec: &ApiSpec, _config: &TestGenerationConfig) -> Result<Vec<TestFile>> {
        let client_test_content = self.generate_junit5_client_test(api_spec)?;
        
        Ok(vec![TestFile {
            name: format!("{}ApiClientTest.java", to_pascal_case(&api_spec.name)),
            path: PathBuf::from(format!("src/test/java/com/example/client/{}ApiClientTest.java", to_pascal_case(&api_spec.name))),
            content: client_test_content,
            test_type: TestType::Unit,
        }])
    }

    fn generate_model_tests(&self, types: &[TypeDefinition], _config: &TestGenerationConfig) -> Result<Vec<TestFile>> {
        let mut test_files = vec![];

        for type_def in types {
            let test_content = self.generate_model_test(type_def)?;
            
            test_files.push(TestFile {
                name: format!("{}Test.java", type_def.name),
                path: PathBuf::from(format!("src/test/java/com/example/client/models/{}Test.java", type_def.name)),
                content: test_content,
                test_type: TestType::Unit,
            });
        }

        Ok(test_files)
    }

    fn generate_integration_tests(&self, api_spec: &ApiSpec, _config: &TestGenerationConfig) -> Result<Vec<TestFile>> {
        let integration_test_content = self.generate_integration_test(api_spec)?;
        
        Ok(vec![TestFile {
            name: format!("{}IntegrationTest.java", to_pascal_case(&api_spec.name)),
            path: PathBuf::from(format!("src/test/java/com/example/client/{}IntegrationTest.java", to_pascal_case(&api_spec.name))),
            content: integration_test_content,
            test_type: TestType::Integration,
        }])
    }

    fn generate_mock_data(&self, api_spec: &ApiSpec, _config: &TestGenerationConfig) -> Result<Vec<MockDataFile>> {
        let mut mock_files = vec![];

        // Generate mock data for each model type
        for type_def in &api_spec.types {
            let mock_data = self.generate_mock_json_for_type(type_def)?;
            
            mock_files.push(MockDataFile {
                name: format!("{}_mock.json", to_snake_case(&type_def.name)),
                path: PathBuf::from(format!("src/test/resources/mock_data/{}_mock.json", to_snake_case(&type_def.name))),
                content: mock_data,
            });
        }

        Ok(mock_files)
    }

    fn generate_test_configs(&self, _config: &TestGenerationConfig) -> Result<Vec<ConfigFile>> {
        self.generate_test_config_files()
    }

    fn target_language(&self) -> TargetLanguage {
        TargetLanguage::Java
    }
}

impl JavaTestGenerator {
    fn generate_mock_json_for_type(&self, type_def: &TypeDefinition) -> Result<String> {
        let mut json_properties = vec![];

        for property in &type_def.properties {
            let mock_value = match &property.data_type.base_type {
                BaseType::String => format!("\"mock_{}\"", property.name),
                BaseType::Integer => "123".to_string(),
                BaseType::Long => "123456789".to_string(),
                BaseType::Boolean => "true".to_string(),
                BaseType::Double => "123.45".to_string(),
                BaseType::Float => "123.45".to_string(),
                BaseType::Date => "\"2023-01-01\"".to_string(),
                BaseType::DateTime => "\"2023-01-01T12:00:00Z\"".to_string(),
                _ => "null".to_string(),
            };

            json_properties.push(format!("  \"{}\": {}", property.name, mock_value));
        }

        Ok(format!("{{\n{}\n}}", json_properties.join(",\n")))
    }
}

// Helper functions
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars: Vec<char> = word.chars().collect();
            if !chars.is_empty() {
                chars[0] = chars[0].to_uppercase().next().unwrap();
            }
            chars.into_iter().collect::<String>()
        })
        .collect()
}

fn to_camel_case(s: &str) -> String {
    let pascal = to_pascal_case(s);
    let mut chars: Vec<char> = pascal.chars().collect();
    if !chars.is_empty() {
        chars[0] = chars[0].to_lowercase().next().unwrap();
    }
    chars.into_iter().collect::<String>()
}

fn to_snake_case(s: &str) -> String {
    s.chars()
        .enumerate()
        .flat_map(|(i, c)| {
            if i > 0 && c.is_uppercase() {
                vec!['_', c.to_lowercase().next().unwrap()]
            } else {
                vec![c.to_lowercase().next().unwrap()]
            }
        })
        .collect()
}

impl Default for JavaTestGenerator {
    fn default() -> Self {
        Self::new()
    }
}