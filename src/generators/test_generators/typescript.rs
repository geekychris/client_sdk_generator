// Copyright (c) 2024 Chris Collins <chris@hitorro.com>
// Licensed under the MIT License

use anyhow::Result;
use std::path::{Path, PathBuf};

use crate::core::config::TargetLanguage;
use crate::core::test_generation::*;
use crate::core::types::{ApiSpec, Operation, TypeDefinition, BaseType};

pub struct TypeScriptTestGenerator;

impl TypeScriptTestGenerator {
    pub fn new() -> Self {
        Self
    }

    fn generate_jest_client_test(&self, api_spec: &ApiSpec) -> Result<String> {
        let class_name = format!("{}ApiClient", to_pascal_case(&api_spec.name));
        
        let mut content = format!(
            r#"import {{ {} }} from '../src/client';
import {{ ClientConfig }} from '../src/config';

// Mock the HTTP client
const mockFetch = jest.fn();
global.fetch = mockFetch;

/**
 * Unit tests for {}ApiClient
 * Generated by SDK Generator
 */
describe('{} API Client', () => {{
    let client: {};
    let config: ClientConfig;

    beforeEach(() => {{
        config = {{
            baseUrl: 'https://api.example.com',
            timeout: 30000,
        }};
        client = new {}(config);
        mockFetch.mockClear();
    }});

    describe('constructor', () => {{
        it('should create client with valid config', () => {{
            expect(client).toBeInstanceOf({});
        }});

        it('should throw error with invalid config', () => {{
            expect(() => new {}(null as any)).toThrow();
        }});
    }});

"#,
            class_name,
            to_pascal_case(&api_spec.name),
            api_spec.name,
            class_name,
            class_name,
            class_name,
            class_name
        );

        // Generate test methods for each operation
        for operation in &api_spec.operations {
            content.push_str(&self.generate_operation_test_methods(operation)?);
        }

        // Generate error handling tests
        content.push_str(&self.generate_error_handling_tests()?);

        content.push_str("});\n");

        Ok(content)
    }

    fn generate_operation_test_methods(&self, operation: &Operation) -> Result<String> {
        let method_name = to_camel_case(&operation.name);
        
        let mut content = format!(
            r#"    describe('{}', () => {{
        it('should successfully call {} operation', async () => {{
            // Given
            const mockResponse = {{
                ok: true,
                status: 200,
                json: () => Promise.resolve({{ success: true }}),
            }};
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When
            const result = await client.{}({});

            // Then
            expect(result).toBeDefined();
            expect(mockFetch).toHaveBeenCalledTimes(1);
        }});

        it('should handle HTTP 404 error', async () => {{
            // Given
            const mockResponse = {{
                ok: false,
                status: 404,
                json: () => Promise.resolve({{ error: 'Not Found' }}),
            }};
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When/Then
            await expect(client.{}({})).rejects.toThrow();
        }});

        it('should handle network timeout', async () => {{
            // Given
            mockFetch.mockRejectedValueOnce(new Error('Network timeout'));

            // When/Then
            await expect(client.{}({})).rejects.toThrow('Network timeout');
        }});
"#,
            operation.name,
            operation.name,
            method_name,
            self.generate_method_parameters(operation)?,
            method_name,
            self.generate_method_parameters(operation)?,
            method_name,
            self.generate_method_parameters(operation)?
        );

        // Generate parameter validation tests
        for param in &operation.parameters {
            if param.required {
                content.push_str(&format!(
                    r#"
        it('should throw error when {} is null', async () => {{
            // When/Then
            await expect(client.{}({})).rejects.toThrow();
        }});
"#,
                    param.name,
                    method_name,
                    self.generate_method_parameters_with_null(operation, &param.name)?
                ));
            }
        }

        content.push_str("    });\n\n");

        Ok(content)
    }

    fn generate_method_parameters(&self, operation: &Operation) -> Result<String> {
        if operation.parameters.is_empty() {
            return Ok(String::new());
        }

        let params: Vec<String> = operation.parameters
            .iter()
            .map(|p| {
                match &p.data_type.base_type {
                    BaseType::String => format!("'test_{}'", p.name),
                    BaseType::Integer | BaseType::Long => "123".to_string(),
                    BaseType::Boolean => "true".to_string(),
                    BaseType::Double | BaseType::Float => "123.45".to_string(),
                    _ => format!("/* TODO: {} */", p.name),
                }
            })
            .collect();

        Ok(params.join(", "))
    }

    fn generate_method_parameters_with_null(&self, operation: &Operation, null_param: &str) -> Result<String> {
        if operation.parameters.is_empty() {
            return Ok(String::new());
        }

        let params: Vec<String> = operation.parameters
            .iter()
            .map(|p| {
                if p.name == null_param {
                    "null".to_string()
                } else {
                    match &p.data_type.base_type {
                        BaseType::String => format!("'test_{}'", p.name),
                        BaseType::Integer | BaseType::Long => "123".to_string(),
                        BaseType::Boolean => "true".to_string(),
                        BaseType::Double | BaseType::Float => "123.45".to_string(),
                        _ => format!("/* TODO: {} */", p.name),
                    }
                }
            })
            .collect();

        Ok(params.join(", "))
    }

    fn generate_error_handling_tests(&self) -> Result<String> {
        Ok(r#"    describe('error handling', () => {
        it('should handle server errors', async () => {
            // Given
            const mockResponse = {
                ok: false,
                status: 500,
                json: () => Promise.resolve({ error: 'Internal Server Error' }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When/Then - test any operation
            // await expect(client.someOperation()).rejects.toThrow();
        });

        it('should handle network errors', async () => {
            // Given
            mockFetch.mockRejectedValueOnce(new Error('Network error'));

            // When/Then - test any operation
            // await expect(client.someOperation()).rejects.toThrow('Network error');
        });
    });

"#.to_string())
    }

    fn generate_model_test(&self, type_def: &TypeDefinition) -> Result<String> {
        let class_name = &type_def.name;
        
        let mut content = format!(
            r#"import {{ {} }} from '../src/models/{}';

/**
 * Unit tests for {} model
 * Generated by SDK Generator
 */
describe('{} Model', () => {{
    let model: {};

    beforeEach(() => {{
        model = new {}();
    }});

    describe('constructor', () => {{
        it('should create instance', () => {{
            expect(model).toBeInstanceOf({});
        }});

        it('should initialize with default values', () => {{
            expect(model).toBeDefined();
        }});
    }});

"#,
            class_name,
            to_snake_case(class_name),
            class_name,
            class_name,
            class_name,
            class_name,
            class_name
        );

        // Generate tests for each property
        for property in &type_def.properties {
            content.push_str(&self.generate_property_tests(type_def, property)?);
        }

        // Generate serialization tests
        content.push_str(&self.generate_serialization_tests(type_def)?);

        content.push_str("});\n");

        Ok(content)
    }

    fn generate_property_tests(&self, _type_def: &TypeDefinition, property: &crate::core::types::Property) -> Result<String> {
        let property_name = &property.name;
        let test_value = match &property.data_type.base_type {
            BaseType::String => "'test_value'".to_string(),
            BaseType::Integer | BaseType::Long => "123".to_string(),
            BaseType::Boolean => "true".to_string(),
            BaseType::Double | BaseType::Float => "123.45".to_string(),
            _ => "/* TODO: generate test value */".to_string(),
        };

        Ok(format!(
            r#"    describe('property: {}', () => {{
        it('should set and get {}', () => {{
            // Given
            const value = {};
            
            // When
            model.{} = value;
            
            // Then
            expect(model.{}).toBe(value);
        }});
    }});

"#,
            property_name,
            property_name,
            test_value,
            property_name,
            property_name
        ))
    }

    fn generate_serialization_tests(&self, type_def: &TypeDefinition) -> Result<String> {
        Ok(format!(
            r#"    describe('serialization', () => {{
        it('should serialize to JSON', () => {{
            // Given
            const model = new {}();
            // TODO: Set test data

            // When
            const json = JSON.stringify(model);

            // Then
            expect(json).toBeDefined();
            expect(json.length).toBeGreaterThan(0);
        }});

        it('should deserialize from JSON', () => {{
            // Given
            const json = '{{}}'; // TODO: Add valid JSON

            // When
            const result = JSON.parse(json) as {};

            // Then
            expect(result).toBeDefined();
        }});

        it('should handle round-trip serialization', () => {{
            // Given
            const original = new {}();
            // TODO: Set test data

            // When
            const json = JSON.stringify(original);
            const deserialized = JSON.parse(json) as {};

            // Then
            expect(deserialized).toEqual(original);
        }});
    }});

"#,
            type_def.name,
            type_def.name,
            type_def.name,
            type_def.name
        ))
    }

    fn generate_integration_test(&self, api_spec: &ApiSpec) -> Result<String> {
        let class_name = format!("{}ApiClient", to_pascal_case(&api_spec.name));
        
        Ok(format!(
            r#"import {{ {} }} from '../src/client';
import {{ ClientConfig }} from '../src/config';

/**
 * Integration tests for {}ApiClient
 * These tests require a running API server
 * Generated by SDK Generator
 * 
 * Run with: npm test -- --testNamePattern="Integration"
 */
describe.skip('{} API Integration Tests', () => {{
    let client: {};
    
    beforeAll(() => {{
        const config: ClientConfig = {{
            baseUrl: process.env.API_BASE_URL || 'http://localhost:8080',
            timeout: 30000,
        }};
        
        client = new {}(config);
    }});

    it('should connect to API server', async () => {{
        expect(client).toBeDefined();
        // TODO: Add actual API call to verify connection
    }});

    // TODO: Add integration tests for each operation
}});
"#,
            class_name,
            to_pascal_case(&api_spec.name),
            api_spec.name,
            class_name,
            class_name
        ))
    }

    fn generate_test_config_files(&self) -> Result<Vec<ConfigFile>> {
        let mut config_files = vec![];

        // Jest configuration
        config_files.push(ConfigFile {
            name: "jest.config.js".to_string(),
            path: PathBuf::from("jest.config.js"),
            content: r#"/** @type {import('jest').Config} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.+(ts|tsx|js)',
    '**/*.(test|spec).+(ts|tsx|js)'
  ],
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: [
    'text',
    'lcov',
    'html',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
};
"#.to_string(),
        });

        // Test setup file
        config_files.push(ConfigFile {
            name: "setup.ts".to_string(),
            path: PathBuf::from("tests/setup.ts"),
            content: r#"// Test setup file
// Generated by SDK Generator

// Global test setup
beforeAll(() => {
  // Setup code that runs before all tests
});

afterAll(() => {
  // Cleanup code that runs after all tests
});

// Mock global fetch if not available
if (!global.fetch) {
  global.fetch = jest.fn();
}

// Custom matchers or global test utilities can go here
"#.to_string(),
        });

        Ok(config_files)
    }
}

impl TestGenerator for TypeScriptTestGenerator {
    fn generate_test_suite(&self, api_spec: &ApiSpec, config: &TestGenerationConfig, _output_path: &Path) -> Result<TestSuite> {
        let mut test_files = vec![];
        let mut mock_data_files = vec![];

        // Generate client tests
        if config.generate_unit_tests {
            test_files.extend(self.generate_client_tests(api_spec, config)?);
            test_files.extend(self.generate_model_tests(&api_spec.types, config)?);
        }

        // Generate integration tests
        if config.generate_integration_tests {
            test_files.extend(self.generate_integration_tests(api_spec, config)?);
        }

        // Generate mock data
        if config.generate_mock_data {
            mock_data_files.extend(self.generate_mock_data(api_spec, config)?);
        }

        let config_files = self.generate_test_configs(config)?;

        Ok(TestSuite {
            name: format!("{}_test_suite", api_spec.name),
            files: test_files,
            mock_data_files,
            config_files,
        })
    }

    fn generate_client_tests(&self, api_spec: &ApiSpec, _config: &TestGenerationConfig) -> Result<Vec<TestFile>> {
        let client_test_content = self.generate_jest_client_test(api_spec)?;
        
        Ok(vec![TestFile {
            name: format!("{}.test.ts", to_snake_case(&format!("{}ApiClient", to_pascal_case(&api_spec.name)))),
            path: PathBuf::from(format!("tests/{}.test.ts", to_snake_case(&format!("{}ApiClient", to_pascal_case(&api_spec.name))))),
            content: client_test_content,
            test_type: TestType::Unit,
        }])
    }

    fn generate_model_tests(&self, types: &[TypeDefinition], _config: &TestGenerationConfig) -> Result<Vec<TestFile>> {
        let mut test_files = vec![];

        for type_def in types {
            let test_content = self.generate_model_test(type_def)?;
            
            test_files.push(TestFile {
                name: format!("{}.test.ts", to_snake_case(&type_def.name)),
                path: PathBuf::from(format!("tests/models/{}.test.ts", to_snake_case(&type_def.name))),
                content: test_content,
                test_type: TestType::Unit,
            });
        }

        Ok(test_files)
    }

    fn generate_integration_tests(&self, api_spec: &ApiSpec, _config: &TestGenerationConfig) -> Result<Vec<TestFile>> {
        let integration_test_content = self.generate_integration_test(api_spec)?;
        
        Ok(vec![TestFile {
            name: format!("{}.integration.test.ts", to_snake_case(&format!("{}ApiClient", to_pascal_case(&api_spec.name)))),
            path: PathBuf::from(format!("tests/{}.integration.test.ts", to_snake_case(&format!("{}ApiClient", to_pascal_case(&api_spec.name))))),
            content: integration_test_content,
            test_type: TestType::Integration,
        }])
    }

    fn generate_mock_data(&self, api_spec: &ApiSpec, _config: &TestGenerationConfig) -> Result<Vec<MockDataFile>> {
        let mut mock_files = vec![];

        // Generate mock data for each model type
        for type_def in &api_spec.types {
            let mock_data = self.generate_mock_json_for_type(type_def)?;
            
            mock_files.push(MockDataFile {
                name: format!("{}_mock.json", to_snake_case(&type_def.name)),
                path: PathBuf::from(format!("tests/fixtures/{}_mock.json", to_snake_case(&type_def.name))),
                content: mock_data,
            });
        }

        Ok(mock_files)
    }

    fn generate_test_configs(&self, _config: &TestGenerationConfig) -> Result<Vec<ConfigFile>> {
        self.generate_test_config_files()
    }

    fn target_language(&self) -> TargetLanguage {
        TargetLanguage::TypeScript
    }
}

impl TypeScriptTestGenerator {
    fn generate_mock_json_for_type(&self, type_def: &TypeDefinition) -> Result<String> {
        let mut json_properties = vec![];

        for property in &type_def.properties {
            let mock_value = match &property.data_type.base_type {
                BaseType::String => format!("\"mock_{}\"", property.name),
                BaseType::Integer | BaseType::Long => "123".to_string(),
                BaseType::Boolean => "true".to_string(),
                BaseType::Double | BaseType::Float => "123.45".to_string(),
                BaseType::Date => "\"2023-01-01\"".to_string(),
                BaseType::DateTime => "\"2023-01-01T12:00:00Z\"".to_string(),
                _ => "null".to_string(),
            };

            json_properties.push(format!("  \"{}\": {}", property.name, mock_value));
        }

        Ok(format!("{{\n{}\n}}", json_properties.join(",\n")))
    }
}

// Helper functions
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars: Vec<char> = word.chars().collect();
            if !chars.is_empty() {
                chars[0] = chars[0].to_uppercase().next().unwrap();
            }
            chars.into_iter().collect::<String>()
        })
        .collect()
}

fn to_camel_case(s: &str) -> String {
    let pascal = to_pascal_case(s);
    let mut chars: Vec<char> = pascal.chars().collect();
    if !chars.is_empty() {
        chars[0] = chars[0].to_lowercase().next().unwrap();
    }
    chars.into_iter().collect::<String>()
}

fn to_snake_case(s: &str) -> String {
    s.chars()
        .enumerate()
        .flat_map(|(i, c)| {
            if i > 0 && c.is_uppercase() {
                vec!['_', c.to_lowercase().next().unwrap()]
            } else {
                vec![c.to_lowercase().next().unwrap()]
            }
        })
        .collect()
}

impl Default for TypeScriptTestGenerator {
    fn default() -> Self {
        Self::new()
    }
}