/**
 * {{spec.name}} TypeScript SDK Tests
 * Generated by client-sdk-generator
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { {{client_class_name}}, ClientConfig } from '../src/client';
import { createConfig } from '../src/config';
{{#each types}}
import { {{name}}, is{{name}}, create{{name}}, validate{{name}} } from '../src/models/{{snake_case name}}';
{{/each}}

// Mock fetch globally
global.fetch = jest.fn();

describe('{{spec.name}} SDK', () => {
  let client: {{client_class_name}};
  let config: ClientConfig;

  beforeEach(() => {
    // Reset all mocks
    jest.resetAllMocks();
    
    // Create test configuration
    config = {
      baseURL: 'https://api.example.com',
      timeout: 30000,
      {{#if authentication}}
      auth: {
        {{#if supports_bearer_auth}}
        bearerToken: 'test-token',
        {{/if}}
        {{#if supports_api_key}}
        apiKey: 'test-api-key',
        {{/if}}
      },
      {{/if}}
    };

    client = new {{client_class_name}}(config);
  });

  describe('Client Configuration', () => {
    it('should create client with valid configuration', () => {
      expect(client).toBeDefined();
      expect(client).toBeInstanceOf({{client_class_name}});
    });

    it('should merge configuration with defaults', () => {
      const mergedConfig = createConfig(config);
      expect(mergedConfig.baseURL).toBe('https://api.example.com');
      expect(mergedConfig.timeout).toBe(30000);
      expect(mergedConfig.userAgent).toMatch(/{{package}}-client/);
    });

    {{#if authentication}}
    {{#if supports_api_key}}
    it('should set API key for authentication', () => {
      client.setApiKey('new-api-key');
      // Verify that subsequent requests include the new API key
      // This would typically be tested by mocking HTTP requests
      expect(client).toBeDefined(); // Placeholder assertion
    });
    {{/if}}

    {{#if supports_bearer_auth}}
    it('should set bearer token for authentication', () => {
      client.setBearerToken('new-bearer-token');
      // Verify that subsequent requests include the new bearer token
      expect(client).toBeDefined(); // Placeholder assertion
    });
    {{/if}}
    {{/if}}
  });

  describe('HTTP Request Handling', () => {
    it('should handle successful responses', async () => {
      const mockResponse = {
        ok: true,
        status: 200,
        json: jest.fn().mockResolvedValue({ success: true }),
        headers: new Headers({ 'content-type': 'application/json' }),
      };
      
      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      // This test would need to be adapted based on actual API operations
      expect(global.fetch).toBeDefined();
    });

    it('should handle error responses', async () => {
      const mockErrorResponse = {
        ok: false,
        status: 404,
        text: jest.fn().mockResolvedValue('Not Found'),
        headers: new Headers(),
      };
      
      (global.fetch as jest.Mock).mockResolvedValueOnce(mockErrorResponse);

      // Test error handling - adapt based on actual API operations
      expect(global.fetch).toBeDefined();
    });

    {{#if features.retry}}
    it('should retry failed requests', async () => {
      const mockFailResponse = {
        ok: false,
        status: 500,
        text: jest.fn().mockResolvedValue('Internal Server Error'),
      };
      
      const mockSuccessResponse = {
        ok: true,
        status: 200,
        json: jest.fn().mockResolvedValue({ success: true }),
        headers: new Headers({ 'content-type': 'application/json' }),
      };
      
      (global.fetch as jest.Mock)
        .mockResolvedValueOnce(mockFailResponse)
        .mockResolvedValueOnce(mockSuccessResponse);

      // Test retry mechanism - adapt based on actual API operations
      expect(global.fetch).toBeDefined();
    });
    {{/if}}

    it('should handle request timeout', async () => {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Timeout')), 100);
      });
      
      (global.fetch as jest.Mock).mockImplementationOnce(() => timeoutPromise);

      // Test timeout handling - adapt based on actual API operations
      expect(global.fetch).toBeDefined();
    });
  });

  {{#each operations}}
  describe('{{name}} Operation', () => {
    it('should call {{name}} with correct parameters', async () => {
      const mockResponse = {
        ok: true,
        status: 200,
        json: jest.fn().mockResolvedValue({}),
        headers: new Headers({ 'content-type': 'application/json' }),
      };
      
      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      {{#if parameters}}
      const parameters = {
        {{#each parameters}}
        {{camel_case name}}: {{#if (eq data_type "string")}}'test-value'{{else if (eq data_type "number")}}123{{else if (eq data_type "boolean")}}true{{else}}{}{{/if}},
        {{/each}}
      };
      {{/if}}

      // TODO: Implement actual API call
      // await client.{{camel_case name}}({{#if parameters}}parameters{{/if}});
      
      expect(global.fetch).toBeDefined();
      // expect(global.fetch).toHaveBeenCalledWith(
      //   expect.stringContaining('{{path}}'),
      //   expect.objectContaining({
      //     method: '{{upper_case method}}',
      //   })
      // );
    });

    {{#if request_body}}
    it('should send request body for {{name}} operation', async () => {
      const mockResponse = {
        ok: true,
        status: 200,
        json: jest.fn().mockResolvedValue({}),
        headers: new Headers({ 'content-type': 'application/json' }),
      };
      
      (global.fetch as jest.Mock).mockResolvedValueOnce(mockResponse);

      const requestBody = { /* TODO: Define request body structure */ };
      
      // TODO: Implement actual API call with body
      // await client.{{camel_case name}}(requestBody);
      
      expect(global.fetch).toBeDefined();
    });
    {{/if}}

    it('should handle {{name}} operation errors', async () => {
      const mockErrorResponse = {
        ok: false,
        status: 400,
        text: jest.fn().mockResolvedValue('Bad Request'),
      };
      
      (global.fetch as jest.Mock).mockResolvedValueOnce(mockErrorResponse);

      // TODO: Test error handling for {{name}} operation
      expect(global.fetch).toBeDefined();
    });
  });

  {{/each}}

  {{#each types}}
  describe('{{name}} Model', () => {
    it('should validate {{name}} type guard', () => {
      const valid{{name}} = {
        {{#each properties}}
        {{#if required}}
        {{camel_case name}}: {{#if (eq data_type "string")}}'test'{{else if (eq data_type "number")}}123{{else if (eq data_type "boolean")}}true{{else}}{}{{/if}},
        {{/if}}
        {{/each}}
      };

      const invalid{{name}} = {};

      expect(is{{name}}(valid{{name}})).toBe(true);
      expect(is{{name}}(invalid{{name}})).toBe(false);
      expect(is{{name}}(null)).toBe(false);
      expect(is{{name}}(undefined)).toBe(false);
    });

    it('should create {{name}} with factory function', () => {
      {{#if (some properties "required")}}
      const {{camel_case name}} = create{{name}}(
        {{#each properties}}
        {{#if required}}
        {{#if (eq data_type "string")}}'test-value'{{else if (eq data_type "number")}}123{{else if (eq data_type "boolean")}}true{{else}}{}{{/if}}{{#unless @last}},{{/unless}}
        {{/if}}
        {{/each}}
      );

      expect({{camel_case name}}).toBeDefined();
      {{#each properties}}
      {{#if required}}
      expect({{camel_case ../name}}.{{camel_case name}}).toBeDefined();
      {{/if}}
      {{/each}}
      {{else}}
      // No required properties for {{name}}
      expect(true).toBe(true);
      {{/if}}
    });

    it('should validate {{name}} object', () => {
      const valid{{name}} = {
        {{#each properties}}
        {{#if required}}
        {{camel_case name}}: {{#if (eq data_type "string")}}'test'{{else if (eq data_type "number")}}123{{else if (eq data_type "boolean")}}true{{else}}{}{{/if}},
        {{/if}}
        {{/each}}
      };

      const invalid{{name}} = {};

      expect(validate{{name}}(valid{{name}})).toEqual([]);
      {{#if (some properties "required")}}
      expect(validate{{name}}(invalid{{name}} as {{name}}).length).toBeGreaterThan(0);
      {{else}}
      expect(validate{{name}}(invalid{{name}} as {{name}})).toEqual([]);
      {{/if}}
    });
  });

  {{/each}}

  {{#if features.async}}
  describe('Async Client', () => {
    it('should support async operations', () => {
      // TypeScript/JavaScript is naturally async, so regular client methods are already async
      expect(client).toBeDefined();
    });
  });
  {{/if}}

  {{#if features.caching}}
  describe('Caching', () => {
    it('should cache responses when enabled', async () => {
      // TODO: Implement caching tests
      expect(true).toBe(true);
    });

    it('should respect cache TTL', async () => {
      // TODO: Implement TTL tests
      expect(true).toBe(true);
    });
  });
  {{/if}}

  {{#if features.telemetry}}
  describe('Telemetry', () => {
    it('should collect request metrics when enabled', async () => {
      // TODO: Implement telemetry tests
      expect(true).toBe(true);
    });
  });
  {{/if}}
});