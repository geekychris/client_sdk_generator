# {{api_name}} gRPC API Documentation

{{#if description}}{{description}}{{/if}}

Go gRPC client SDK for {{api_name}}.

**Version:** {{version}}

## Installation

```bash
go mod init your-project
go get {{go_module}}
```

## Basic Usage

```go
package main

import (
    "context"
    "fmt"
    "log"
    "{{go_module}}"
)

func main() {
    config := {{package_name}}.ClientConfig{
        Host:   "api.example.com",
        Port:   443,
        UseTLS: true,
    }
    
    client, err := {{package_name}}.NewGrpcClient(config)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()
    
    ctx := context.Background()
    
    // Example service call
    request := &{{package_name}}.ExampleRequest{
        Message: "Hello, gRPC!",
    }
    
    response, err := client.ExampleMethod(ctx, request)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Response: %+v\n", response)
}
```

## Authentication

{{#if authentication}}
This API uses {{authentication.auth_type}} authentication.

{{#if (eq authentication.auth_type "ApiKey")}}
### API Key Authentication

Set your API key in the client configuration:

```go
config := {{package_name}}.ClientConfig{
    Host:   "api.example.com",
    Port:   443,
    UseTLS: true,
    Auth: &{{package_name}}.AuthConfig{
        APIKey: "your-api-key-here",
    },
}
```
{{/if}}

{{#if (eq authentication.auth_type "Http")}}
### Bearer Token Authentication

Set your bearer token in the client configuration:

```go
config := {{package_name}}.ClientConfig{
    Host:   "api.example.com",
    Port:   443,
    UseTLS: true,
    Auth: &{{package_name}}.AuthConfig{
        BearerToken: "your-bearer-token-here",
    },
}
```
{{/if}}

{{#if (eq authentication.auth_type "OAuth2")}}
### OAuth2 Authentication

Set your OAuth2 token in the client configuration:

```go
config := {{package_name}}.ClientConfig{
    Host:   "api.example.com",
    Port:   443,
    UseTLS: true,
    Auth: &{{package_name}}.AuthConfig{
        OAuthToken: "your-oauth-token-here",
    },
}
```
{{/if}}

{{else}}
No authentication is required for this API.
{{/if}}

## Services and Methods

{{#each services}}
### {{pascal_case name}} Service

{{#if description}}{{description}}{{else}}{{pascal_case name}} gRPC service{{/if}}

{{#each methods}}
#### {{pascal_case name}}

{{#if description}}{{description}}{{else}}{{pascal_case name}} method{{/if}}

**Request Type:** `{{pascal_case request_type}}`  
**Response Type:** `{{pascal_case response_type}}`  
{{#if streaming}}
**Streaming:** {{streaming_type}}
{{/if}}

```go
// Method signature
func (c *GrpcClient) {{pascal_case name}}(ctx context.Context, req *{{pascal_case request_type}}) (*{{pascal_case response_type}}, error)
```

**Example Usage:**

{{#if client_streaming}}
```go
// Client streaming
stream, err := client.{{pascal_case name}}Stream(ctx)
if err != nil {
    log.Fatal(err)
}

// Send multiple requests
for i := 0; i < 10; i++ {
    req := &{{pascal_case request_type}}{
        Data: fmt.Sprintf("message_%d", i),
    }
    if err := stream.Send(req); err != nil {
        log.Fatal(err)
    }
}

// Close and receive response
response, err := stream.CloseAndRecv()
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Response: %+v\n", response)
```
{{else if server_streaming}}
```go
// Server streaming
request := &{{pascal_case request_type}}{
    Query: "example query",
}

stream, err := client.{{pascal_case name}}Stream(ctx, request)
if err != nil {
    log.Fatal(err)
}

for {
    response, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Received: %+v\n", response)
}
```
{{else if bidirectional_streaming}}
```go
// Bidirectional streaming
stream, err := client.{{pascal_case name}}Stream(ctx)
if err != nil {
    log.Fatal(err)
}

// Start a goroutine to receive responses
go func() {
    for {
        response, err := stream.Recv()
        if err == io.EOF {
            return
        }
        if err != nil {
            log.Printf("Receive error: %v", err)
            return
        }
        fmt.Printf("Received: %+v\n", response)
    }
}()

// Send requests
for i := 0; i < 10; i++ {
    req := &{{pascal_case request_type}}{
        Data: fmt.Sprintf("message_%d", i),
    }
    if err := stream.Send(req); err != nil {
        log.Fatal(err)
    }
}

// Close the send stream
if err := stream.CloseSend(); err != nil {
    log.Fatal(err)
}
```
{{else}}
```go
// Unary call
request := &{{pascal_case request_type}}{
    {{#each request_fields}}
    {{#if required}}{{pascal_case name}}: {{#if (eq field_type "string")}}"example_value"{{else if (eq field_type "int32")}}123{{else if (eq field_type "int64")}}123{{else if (eq field_type "bool")}}true{{else}}nil{{/if}},{{/if}}
    {{/each}}
}

response, err := client.{{pascal_case name}}(ctx, request)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Response: %+v\n", response)
```
{{/if}}

---

{{/each}}
{{/each}}

## Message Types

{{#each messages}}
### {{pascal_case name}}

{{#if description}}{{description}}{{else}}{{pascal_case name}} message type{{/if}}

{{#if fields}}
**Fields:**

| Name | Type | Required | Description |
|------|------|----------|-------------|
{{#each fields}}
| `{{pascal_case name}}` | {{go_type field_type}} | {{#if required}}✅{{else}}❌{{/if}} | {{#if description}}{{description}}{{else}}{{pascal_case name}} field{{/if}} |
{{/each}}
{{/if}}

```go
type {{pascal_case name}} struct {
    {{#each fields}}
    {{pascal_case name}} {{go_type field_type}} `protobuf:"{{protobuf_tag}}"` {{#if description}}// {{description}}{{/if}}
    {{/each}}
}
```

**Creating {{pascal_case name}}:**

```go
message := &{{pascal_case name}}{
    {{#each fields}}
    {{#if required}}
    {{pascal_case name}}: {{#if (eq field_type "string")}}"example_value"{{else if (eq field_type "int32")}}123{{else if (eq field_type "int64")}}123{{else if (eq field_type "bool")}}true{{else}}nil{{/if}},
    {{/if}}
    {{/each}}
}
```

---

{{/each}}

## Error Handling

The gRPC client provides comprehensive error handling:

```go
import (
    "context"
    "fmt"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "{{go_module}}"
)

func handleGrpcErrors() {
    client, err := {{package_name}}.NewGrpcClient(config)
    if err != nil {
        log.Fatal(err)
    }
    defer client.Close()
    
    request := &{{package_name}}.ExampleRequest{}
    response, err := client.ExampleMethod(ctx, request)
    
    if err != nil {
        // Check for gRPC-specific errors
        if st, ok := status.FromError(err); ok {
            switch st.Code() {
            case codes.NotFound:
                fmt.Println("Resource not found")
            case codes.PermissionDenied:
                fmt.Println("Permission denied")
            case codes.Unauthenticated:
                fmt.Println("Authentication failed")
            case codes.DeadlineExceeded:
                fmt.Println("Request timed out")
            case codes.Unavailable:
                fmt.Println("Service unavailable")
            default:
                fmt.Printf("gRPC error: %s (code: %s)\n", st.Message(), st.Code())
            }
            
            // Handle error details if any
            for _, detail := range st.Details() {
                fmt.Printf("Error detail: %+v\n", detail)
            }
        } else {
            // Handle other errors (connection, etc.)
            fmt.Printf("Client error: %v\n", err)
        }
    }
}
```

### Common gRPC Status Codes

| Code | Description |
|------|-------------|
| `OK` | Success |
| `CANCELLED` | Operation was cancelled |
| `UNKNOWN` | Unknown error |
| `INVALID_ARGUMENT` | Invalid arguments provided |
| `DEADLINE_EXCEEDED` | Request timeout |
| `NOT_FOUND` | Resource not found |
| `ALREADY_EXISTS` | Resource already exists |
| `PERMISSION_DENIED` | Insufficient permissions |
| `UNAUTHENTICATED` | Authentication failed |
| `RESOURCE_EXHAUSTED` | Resource exhausted (rate limiting) |
| `FAILED_PRECONDITION` | Precondition failed |
| `ABORTED` | Operation aborted |
| `OUT_OF_RANGE` | Value out of range |
| `UNIMPLEMENTED` | Method not implemented |
| `INTERNAL` | Internal server error |
| `UNAVAILABLE` | Service unavailable |
| `DATA_LOSS` | Data loss or corruption |

### Retry Logic

```go
import (
    "time"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

func retryableCall() {
    var response *{{package_name}}.ExampleResponse
    var err error
    
    maxRetries := 3
    baseDelay := time.Second
    
    for attempt := 0; attempt <= maxRetries; attempt++ {
        response, err = client.ExampleMethod(ctx, request)
        if err == nil {
            break // Success
        }
        
        // Check if error is retryable
        if st, ok := status.FromError(err); ok {
            switch st.Code() {
            case codes.Unavailable, codes.DeadlineExceeded, codes.ResourceExhausted:
                if attempt < maxRetries {
                    delay := baseDelay * time.Duration(1<<attempt) // Exponential backoff
                    fmt.Printf("Attempt %d failed, retrying in %v...\n", attempt+1, delay)
                    time.Sleep(delay)
                    continue
                }
            }
        }
        
        // Non-retryable error or max retries exceeded
        break
    }
    
    if err != nil {
        log.Fatal(err)
    }
}
```

## Client Configuration

The `ClientConfig` struct provides various configuration options:

### Basic Configuration

```go
config := {{package_name}}.ClientConfig{
    Host:    "api.example.com",
    Port:    443,
    UseTLS:  true,
    Timeout: 30 * time.Second,
}
```

### TLS Configuration

```go
import (
    "crypto/tls"
    "crypto/x509"
)

// Custom TLS configuration
tlsConfig := &tls.Config{
    ServerName: "api.example.com",
    // Add custom CA certificates if needed
    RootCAs: customCertPool,
}

config := {{package_name}}.ClientConfig{
    Host:      "api.example.com",
    Port:      443,
    UseTLS:    true,
    TLSConfig: tlsConfig,
}
```

### Connection Pool Configuration

```go
config := {{package_name}}.ClientConfig{
    Host:               "api.example.com",
    Port:               443,
    UseTLS:             true,
    MaxConnectionIdle:  5 * time.Minute,
    MaxConnectionAge:   30 * time.Minute,
    KeepAliveTime:      30 * time.Second,
    KeepAliveTimeout:   10 * time.Second,
    PermitWithoutStream: true,
}
```

{{#if features.retry}}
### Retry Configuration

```go
config := {{package_name}}.ClientConfig{
    Host:         "api.example.com",
    Port:         443,
    UseTLS:       true,
    RetryEnabled: true,
    MaxRetries:   3,
    RetryDelay:   1 * time.Second,
    RetryBackoff: 2.0, // Exponential backoff multiplier
}
```

Retries are automatically performed for:
- Network connectivity issues
- gRPC UNAVAILABLE status
- gRPC DEADLINE_EXCEEDED status
- gRPC RESOURCE_EXHAUSTED status
{{/if}}

{{#if features.telemetry}}
### Telemetry and Metrics

```go
config := {{package_name}}.ClientConfig{
    Host:             "api.example.com",
    Port:             443,
    UseTLS:           true,
    TelemetryEnabled: true,
    MetricsEndpoint:  "https://metrics.example.com",
}
```

Collected metrics include:
- Request duration by method
- Request count by method
- Error count by method and status code
- Success/failure rates
- Connection pool statistics
{{/if}}

## Context and Cancellation

All gRPC operations support Go's context for cancellation and timeouts:

```go
import (
    "context"
    "time"
)

// With timeout
ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()

response, err := client.ExampleMethod(ctx, request)
if err != nil {
    if ctx.Err() == context.DeadlineExceeded {
        fmt.Println("Request timed out")
    } else {
        fmt.Printf("Request error: %v\n", err)
    }
}

// With cancellation
ctx, cancel = context.WithCancel(context.Background())

// Cancel the context from another goroutine
go func() {
    time.Sleep(5 * time.Second)
    cancel()
}()

stream, err := client.ExampleStreamingMethod(ctx, request)
if err == nil {
    for {
        response, err := stream.Recv()
        if err != nil {
            if ctx.Err() == context.Canceled {
                fmt.Println("Stream cancelled")
            }
            break
        }
        // Process response
    }
}
```

## Connection Management

### Connection Pooling

The client automatically manages connection pooling:

```go
// The client maintains a single connection that can be reused
client, err := {{package_name}}.NewGrpcClient(config)
if err != nil {
    log.Fatal(err)
}

// Reuse the same client for multiple requests
for i := 0; i < 100; i++ {
    response, err := client.ExampleMethod(ctx, request)
    if err != nil {
        log.Printf("Request %d failed: %v", i, err)
        continue
    }
    // Process response
}

// Close when done
client.Close()
```

### Health Checking

```go
// Check connection health
if err := client.HealthCheck(ctx); err != nil {
    fmt.Printf("Health check failed: %v\n", err)
    // Reconnect or handle error
}
```

---

*This documentation was generated automatically from the Protocol Buffer definitions.*