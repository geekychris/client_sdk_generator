# {{api_name}} Go gRPC SDK

{{#if description}}{{description}}{{/if}}

A Go gRPC client library for the {{api_name}} API, generated by client-sdk-generator.

## Installation

```bash
go mod init your-project
go get {{go_module}}
go get google.golang.org/grpc
go get google.golang.org/protobuf/types/known/emptypb
```

## Usage

### Basic Usage

```go
package main

import (
    "context"
    "fmt"
    "log"
    "{{go_module}}"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

func main() {
    // Create gRPC connection
    conn, err := grpc.Dial("{{grpc_endpoint}}", grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        log.Fatal(err)
    }
    defer conn.Close()
    
    // Create client
    client := {{package_name}}.New{{class_name}}Client(conn)
    ctx := context.Background()
    
    {{#each services}}
    {{#each methods}}
    {{#if @first}}
    // Example: {{name}}
    {{#if client_streaming}}
    // Client streaming example
    stream, err := client.{{go_name name}}(ctx)
    if err != nil {
        log.Fatal(err)
    }
    // Send requests...
    // stream.Send(request)
    response, err := stream.CloseAndRecv()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Response: %+v\n", response)
    {{else if server_streaming}}
    // Server streaming example
    request := &{{package_name}}.{{request_type}}{
        // Set request fields...
    }
    stream, err := client.{{go_name name}}(ctx, request)
    if err != nil {
        log.Fatal(err)
    }
    for {
        response, err := stream.Recv()
        if err != nil {
            if err == io.EOF {
                break
            }
            log.Fatal(err)
        }
        fmt.Printf("Response: %+v\n", response)
    }
    {{else if bidirectional_streaming}}
    // Bidirectional streaming example
    stream, err := client.{{go_name name}}(ctx)
    if err != nil {
        log.Fatal(err)
    }
    // Handle sending and receiving in separate goroutines
    {{else}}
    // Unary call example
    request := &{{package_name}}.{{request_type}}{
        // Set request fields...
    }
    response, err := client.{{go_name name}}(ctx, request)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Response: %+v\n", response)
    {{/if}}
    {{/if}}
    {{/each}}
    {{/each}}
}
```

### TLS Connection

```go
import (
    "crypto/tls"
    "google.golang.org/grpc/credentials"
)

// With system certificate pool
creds := credentials.NewTLS(&tls.Config{ServerName: "{{server_name}}"})
conn, err := grpc.Dial("{{grpc_endpoint}}", grpc.WithTransportCredentials(creds))

// With custom certificate
cert, err := tls.LoadX509KeyPair("client.crt", "client.key")
if err != nil {
    log.Fatal(err)
}
creds := credentials.NewTLS(&tls.Config{
    Certificates: []tls.Certificate{cert},
    ServerName:   "{{server_name}}",
})
conn, err := grpc.Dial("{{grpc_endpoint}}", grpc.WithTransportCredentials(creds))
```

{{#if authentication}}
### Authentication

This SDK supports the following authentication methods:

{{#if supports_bearer_auth}}
#### Bearer Token Authentication

```go
import (
    "context"
    "google.golang.org/grpc/metadata"
)

// Add bearer token to context
token := "your-bearer-token"
ctx := metadata.AppendToOutgoingContext(context.Background(), "authorization", "Bearer "+token)

// Use authenticated context for calls
response, err := client.SomeMethod(ctx, request)
```
{{/if}}

{{#if supports_api_key}}
#### API Key Authentication

```go
import (
    "context"
    "google.golang.org/grpc/metadata"
)

// Add API key to context
apiKey := "your-api-key"
ctx := metadata.AppendToOutgoingContext(context.Background(), "{{auth_header_name}}", apiKey)

// Use authenticated context for calls
response, err := client.SomeMethod(ctx, request)
```
{{/if}}

#### Using Interceptors for Authentication

```go
import (
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
)

func authInterceptor(token string) grpc.UnaryClientInterceptor {
    return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
        ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+token)
        return invoker(ctx, method, req, reply, cc, opts...)
    }
}

conn, err := grpc.Dial("{{grpc_endpoint}}", 
    grpc.WithUnaryInterceptor(authInterceptor("your-token")))
```
{{/if}}

## Service Methods

{{#each services}}
### {{name}} Service

{{#if description}}{{description}}{{/if}}

```go
// Create service client
client := {{../package_name}}.New{{class_name name}}Client(conn)
```

{{#each methods}}
#### `{{go_name name}}`

{{#if description}}{{description}}{{/if}}

**Request Type:** `{{request_type}}`  
**Response Type:** `{{response_type}}`  
{{#if streaming}}**Streaming:** {{streaming_type}}{{/if}}

```go
{{#if client_streaming}}
// Client streaming
stream, err := client.{{go_name name}}(ctx)
if err != nil {
    return err
}

// Send multiple requests
for _, req := range requests {
    if err := stream.Send(req); err != nil {
        return err
    }
}

response, err := stream.CloseAndRecv()
{{else if server_streaming}}
// Server streaming
request := &{{../../package_name}}.{{request_type}}{/* fields */}
stream, err := client.{{go_name name}}(ctx, request)
if err != nil {
    return err
}

for {
    response, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        return err
    }
    // Process response
}
{{else if bidirectional_streaming}}
// Bidirectional streaming
stream, err := client.{{go_name name}}(ctx)
if err != nil {
    return err
}

// Handle sending and receiving concurrently
go func() {
    defer stream.CloseSend()
    for _, req := range requests {
        if err := stream.Send(req); err != nil {
            return
        }
    }
}()

for {
    response, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        return err
    }
    // Process response
}
{{else}}
// Unary call
request := &{{../../package_name}}.{{request_type}}{/* fields */}
response, err := client.{{go_name name}}(ctx, request)
{{/if}}
```

{{/each}}
{{/each}}

## Message Types

{{#each messages}}
### `{{name}}`

{{#if description}}{{description}}{{/if}}

```go
type {{name}} struct {
    {{#each fields}}
    {{go_name}} {{go_type}} `protobuf:"{{protobuf_tag}}" json:"{{json_name}}"`
    {{/each}}
}
```

{{/each}}

## Advanced Features

### Connection Pooling

```go
import "google.golang.org/grpc/keepalive"

kacp := keepalive.ClientParameters{
    Time:                10 * time.Second,
    Timeout:             time.Second,
    PermitWithoutStream: true,
}

conn, err := grpc.Dial("{{grpc_endpoint}}", 
    grpc.WithKeepaliveParams(kacp))
```

### Request Timeout

```go
import (
    "context"
    "time"
)

ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()

response, err := client.SomeMethod(ctx, request)
```

### Retry Configuration

```go
import "google.golang.org/grpc"

conn, err := grpc.Dial("{{grpc_endpoint}}", 
    grpc.WithDefaultServiceConfig(`{
        "methodConfig": [{
            "name": [{"service": "{{package_name}}.{{service_name}}"}],
            "retryPolicy": {
                "MaxAttempts": 4,
                "InitialBackoff": ".01s",
                "MaxBackoff": ".01s",
                "BackoffMultiplier": 1.0,
                "RetryableStatusCodes": [ "UNAVAILABLE", "DEADLINE_EXCEEDED" ]
            }
        }]
    }`))
```

### Load Balancing

```go
conn, err := grpc.Dial("{{grpc_endpoint}}", 
    grpc.WithDefaultServiceConfig(`{"loadBalancingPolicy":"round_robin"}`))
```

## Error Handling

gRPC provides structured error handling with status codes:

```go
import (
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

response, err := client.SomeMethod(ctx, request)
if err != nil {
    if st, ok := status.FromError(err); ok {
        switch st.Code() {
        case codes.NotFound:
            // Handle not found
        case codes.PermissionDenied:
            // Handle permission denied
        case codes.Unavailable:
            // Handle service unavailable
        default:
            // Handle other errors
            fmt.Printf("gRPC error: %v\n", st.Message())
        }
    }
}
```

## Health Checking

```go
import (
    "google.golang.org/grpc/health/grpc_health_v1"
)

healthClient := grpc_health_v1.NewHealthClient(conn)
resp, err := healthClient.Check(ctx, &grpc_health_v1.HealthCheckRequest{
    Service: "{{service_name}}",
})
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Service health: %s\n", resp.Status)
```

## License

This SDK is generated by client-sdk-generator and is available under the MIT License.