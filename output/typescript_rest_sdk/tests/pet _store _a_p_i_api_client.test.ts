import { Pet Store APIApiClient } from '../src/client';
import { ClientConfig } from '../src/config';

// Mock the HTTP client
const mockFetch = jest.fn();
global.fetch = mockFetch;

/**
 * Unit tests for Pet Store APIApiClient
 * Generated by SDK Generator
 */
describe('Pet Store API API Client', () => {
    let client: Pet Store APIApiClient;
    let config: ClientConfig;

    beforeEach(() => {
        config = {
            baseUrl: 'https://api.example.com',
            timeout: 30000,
        };
        client = new Pet Store APIApiClient(config);
        mockFetch.mockClear();
    });

    describe('constructor', () => {
        it('should create client with valid config', () => {
            expect(client).toBeInstanceOf(Pet Store APIApiClient);
        });

        it('should throw error with invalid config', () => {
            expect(() => new Pet Store APIApiClient(null as any)).toThrow();
        });
    });

    describe('listPets', () => {
        it('should successfully call listPets operation', async () => {
            // Given
            const mockResponse = {
                ok: true,
                status: 200,
                json: () => Promise.resolve({ success: true }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When
            const result = await client.listPets('test_limit', 'test_tag');

            // Then
            expect(result).toBeDefined();
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });

        it('should handle HTTP 404 error', async () => {
            // Given
            const mockResponse = {
                ok: false,
                status: 404,
                json: () => Promise.resolve({ error: 'Not Found' }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When/Then
            await expect(client.listPets('test_limit', 'test_tag')).rejects.toThrow();
        });

        it('should handle network timeout', async () => {
            // Given
            mockFetch.mockRejectedValueOnce(new Error('Network timeout'));

            // When/Then
            await expect(client.listPets('test_limit', 'test_tag')).rejects.toThrow('Network timeout');
        });
    });

    describe('createPet', () => {
        it('should successfully call createPet operation', async () => {
            // Given
            const mockResponse = {
                ok: true,
                status: 200,
                json: () => Promise.resolve({ success: true }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When
            const result = await client.createPet();

            // Then
            expect(result).toBeDefined();
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });

        it('should handle HTTP 404 error', async () => {
            // Given
            const mockResponse = {
                ok: false,
                status: 404,
                json: () => Promise.resolve({ error: 'Not Found' }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When/Then
            await expect(client.createPet()).rejects.toThrow();
        });

        it('should handle network timeout', async () => {
            // Given
            mockFetch.mockRejectedValueOnce(new Error('Network timeout'));

            // When/Then
            await expect(client.createPet()).rejects.toThrow('Network timeout');
        });
    });

    describe('getPet', () => {
        it('should successfully call getPet operation', async () => {
            // Given
            const mockResponse = {
                ok: true,
                status: 200,
                json: () => Promise.resolve({ success: true }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When
            const result = await client.getPet('test_petId');

            // Then
            expect(result).toBeDefined();
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });

        it('should handle HTTP 404 error', async () => {
            // Given
            const mockResponse = {
                ok: false,
                status: 404,
                json: () => Promise.resolve({ error: 'Not Found' }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When/Then
            await expect(client.getPet('test_petId')).rejects.toThrow();
        });

        it('should handle network timeout', async () => {
            // Given
            mockFetch.mockRejectedValueOnce(new Error('Network timeout'));

            // When/Then
            await expect(client.getPet('test_petId')).rejects.toThrow('Network timeout');
        });

        it('should throw error when petId is null', async () => {
            // When/Then
            await expect(client.getPet(null)).rejects.toThrow();
        });
    });

    describe('updatePet', () => {
        it('should successfully call updatePet operation', async () => {
            // Given
            const mockResponse = {
                ok: true,
                status: 200,
                json: () => Promise.resolve({ success: true }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When
            const result = await client.updatePet('test_petId');

            // Then
            expect(result).toBeDefined();
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });

        it('should handle HTTP 404 error', async () => {
            // Given
            const mockResponse = {
                ok: false,
                status: 404,
                json: () => Promise.resolve({ error: 'Not Found' }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When/Then
            await expect(client.updatePet('test_petId')).rejects.toThrow();
        });

        it('should handle network timeout', async () => {
            // Given
            mockFetch.mockRejectedValueOnce(new Error('Network timeout'));

            // When/Then
            await expect(client.updatePet('test_petId')).rejects.toThrow('Network timeout');
        });

        it('should throw error when petId is null', async () => {
            // When/Then
            await expect(client.updatePet(null)).rejects.toThrow();
        });
    });

    describe('deletePet', () => {
        it('should successfully call deletePet operation', async () => {
            // Given
            const mockResponse = {
                ok: true,
                status: 200,
                json: () => Promise.resolve({ success: true }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When
            const result = await client.deletePet('test_petId');

            // Then
            expect(result).toBeDefined();
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });

        it('should handle HTTP 404 error', async () => {
            // Given
            const mockResponse = {
                ok: false,
                status: 404,
                json: () => Promise.resolve({ error: 'Not Found' }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When/Then
            await expect(client.deletePet('test_petId')).rejects.toThrow();
        });

        it('should handle network timeout', async () => {
            // Given
            mockFetch.mockRejectedValueOnce(new Error('Network timeout'));

            // When/Then
            await expect(client.deletePet('test_petId')).rejects.toThrow('Network timeout');
        });

        it('should throw error when petId is null', async () => {
            // When/Then
            await expect(client.deletePet(null)).rejects.toThrow();
        });
    });

    describe('error handling', () => {
        it('should handle server errors', async () => {
            // Given
            const mockResponse = {
                ok: false,
                status: 500,
                json: () => Promise.resolve({ error: 'Internal Server Error' }),
            };
            mockFetch.mockResolvedValueOnce(mockResponse as Response);

            // When/Then - test any operation
            // await expect(client.someOperation()).rejects.toThrow();
        });

        it('should handle network errors', async () => {
            // Given
            mockFetch.mockRejectedValueOnce(new Error('Network error'));

            // When/Then - test any operation
            // await expect(client.someOperation()).rejects.toThrow('Network error');
        });
    });

});
